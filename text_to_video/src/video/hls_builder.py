"""HLS output builder for FFmpeg video composition."""

from pathlib import Path
from typing import List, Tuple

from config import VIDEO_FPS, VIDEO_WIDTH, VIDEO_HEIGHT


def build_hls_output(
    background_path: Path,
    audio_path: Path,
    filter_complex: str,
    filter_file: Path,
    random_start: float,
    total_duration: float,
    output_dir: Path,
    title: str = "Educational Content"
) -> Tuple[List[str], Path]:
    """
    Build FFmpeg command for HLS output with proper segmenting.
    
    Args:
        background_path: Path to background video
        audio_path: Path to concatenated audio file
        filter_complex: Filter complex string
        filter_file: Path to filter complex file
        random_start: Random start time in background video
        total_duration: Total duration of the video
        output_dir: Directory to output HLS files
        title: Video title for metadata
        
    Returns:
        Tuple of (ffmpeg_command_list, rendition_playlist_path)
    """
    # Create 720p directory for segments
    hls_dir = output_dir / "720p"
    hls_dir.mkdir(parents=True, exist_ok=True)
    
    # Write filter complex to file
    filter_file.write_text(filter_complex, encoding='utf-8')
    
    # Calculate GOP size: 2 seconds * fps = 48 frames for 24fps
    gop_size = int(2.0 * VIDEO_FPS)
    
    # HLS output parameters
    segment_pattern = str(hls_dir / "seg_%03d.ts")
    playlist_path = hls_dir / "index.m3u8"
    
    # Build FFmpeg command for HLS
    cmd = [
        'ffmpeg',
        '-ss', str(random_start),
        '-stream_loop', '-1',
        '-i', str(background_path),
        '-i', str(audio_path),
        '-filter_complex_script', str(filter_file),
        '-map', '[v]',
        '-map', '1:a',
        '-shortest',
        # Video encoding: H.264 High profile, level 3.1-4.0
        '-c:v', 'libx264',
        '-profile:v', 'high',
        '-level', '4.0',  # Level 4.0 (can be 3.1-4.0 range)
        '-preset', 'medium',
        '-crf', '23',  # CRF 23 as specified
        '-maxrate', '3M',  # Optional bitrate cap: 3 Mbps
        '-bufsize', '6M',  # Buffer size: 6 Mbps
        # Keyframe settings: GOP matches segment boundaries
        '-g', str(gop_size),  # GOP size = 48 frames (2 seconds at 24fps)
        '-keyint_min', str(gop_size),  # Minimum keyframe interval
        '-sc_threshold', '0',  # Disable scene cut detection (scenecut off)
        '-pix_fmt', 'yuv420p',
        # Audio encoding: AAC-LC, 44.1 kHz, stereo, 128 kbps
        '-c:a', 'aac',
        '-b:a', '128k',
        '-ar', '44100',  # 44.1 kHz (can also use 48000)
        '-ac', '2',  # Stereo
        '-profile:a', 'aac_low',  # AAC-LC profile
        # HLS output settings
        '-f', 'hls',
        '-hls_time', '2.0',  # 2-second segments
        '-hls_playlist_type', 'vod',  # VOD playlist type
        '-hls_segment_filename', segment_pattern,
        '-hls_list_size', '0',  # Keep all segments in playlist
        '-hls_flags', 'independent_segments',  # Each segment can be decoded independently
        # Metadata
        '-metadata', f'title={title}',
        '-metadata', 'comment=Generated by PeterCS',
        '-y',
        str(playlist_path)
    ]
    
    return cmd, playlist_path


def create_master_playlist(
    output_dir: Path,
    rendition_playlist: Path,
    video_width: int = None,
    video_height: int = None
) -> Path:
    """
    Create master.m3u8 playlist pointing to rendition.
    
    Args:
        output_dir: Directory to output master playlist
        rendition_playlist: Path to the rendition playlist (720p/index.m3u8)
        video_width: Video width in pixels (defaults to VIDEO_WIDTH from config)
        video_height: Video height in pixels (defaults to VIDEO_HEIGHT from config)
        
    Returns:
        Path to master playlist
    """
    if video_width is None:
        video_width = VIDEO_WIDTH
    if video_height is None:
        video_height = VIDEO_HEIGHT
        
    master_playlist = output_dir / "master.m3u8"
    
    # Calculate bandwidth estimate (rough: bitrate * 1.2 for overhead)
    # Using maxrate 3M + audio 128k = ~3.1M, estimate ~3.7M total with overhead
    bandwidth = 3700000  # ~3.7 Mbps
    
    # H.264 codec string: avc1.640028 (High profile, level 4.0)
    # AAC codec string: mp4a.40.2 (AAC-LC)
    codecs = 'avc1.640028,mp4a.40.2'
    
    # Relative path from master to rendition
    relative_path = rendition_playlist.relative_to(output_dir)
    relative_path_str = str(relative_path).replace('\\', '/')
    
    master_content = f"""#EXTM3U
#EXT-X-VERSION:3
#EXT-X-STREAM-INF:BANDWIDTH={bandwidth},RESOLUTION={video_width}x{video_height},CODECS="{codecs}"
{relative_path_str}
"""
    
    master_playlist.write_text(master_content, encoding='utf-8')
    return master_playlist


def generate_poster_image(
    first_segment_path: Path,
    output_path: Path
) -> Path:
    """
    Generate poster image from first segment of HLS video.
    
    Args:
        first_segment_path: Path to first segment (seg_000.ts)
        output_path: Path to save poster.jpg
        
    Returns:
        Path to generated poster image
    """
    import subprocess
    
    # Extract frame at 1 second mark as poster
    cmd = [
        'ffmpeg',
        '-i', str(first_segment_path),
        '-ss', '00:00:01',
        '-vframes', '1',
        '-y',  # Overwrite if exists
        str(output_path)
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"Warning: Failed to generate poster image: {result.stderr}")
        # Try extracting frame at 0 seconds as fallback
        cmd_fallback = [
            'ffmpeg',
            '-i', str(first_segment_path),
            '-ss', '00:00:00',
            '-vframes', '1',
            '-y',
            str(output_path)
        ]
        result_fallback = subprocess.run(cmd_fallback, capture_output=True, text=True)
        if result_fallback.returncode != 0:
            raise RuntimeError(f"Failed to generate poster image: {result_fallback.stderr}")
    
    return output_path
